/*
 * Copyright (c) 2023-2025 Datalayer, Inc.
 * Distributed under the terms of the Modified BSD License.
 */

/**
 * Tests for RuntimeProgressBar component.
 * Tests progress bar visualization, color transitions, and countdown timer.
 *
 * @module RuntimeProgressBar.test
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { render, waitFor } from '@testing-library/react';
import { RuntimeProgressBar } from '../RuntimeProgressBar';

describe('RuntimeProgressBar', () => {
  let mockGetRuntime: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();

    mockGetRuntime = vi.fn();
    (window as unknown as Record<string, unknown>).datalayerClient = {
      getRuntime: mockGetRuntime,
    };
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('rendering', () => {
    it('should render nothing when no runtime is provided', async () => {
      const { container } = render(<RuntimeProgressBar />);

      await vi.runAllTimersAsync();
      expect(container.firstChild).toBeNull();
    });

    it('should render progress bar when runtime is provided', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 30 * 60 * 1000); // 30 mins ago
      const expiredAt = new Date(now + 30 * 60 * 1000); // 30 mins from now

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      // Advance timers to allow promises to resolve
      await vi.runAllTimersAsync();

      await waitFor(
        () => {
          expect(mockGetRuntime).toHaveBeenCalledWith('runtime-123');
        },
        { timeout: 100 }
      );

      // Should render progress bar container
      expect(container.querySelector('[style*="height"]')).toBeInTheDocument();
    });
  });

  describe('runtime details fetching', () => {
    it('should fetch runtime details on mount', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 1000).toISOString(),
        expiredAt: new Date(now + 59000).toISOString(),
      });

      render(<RuntimeProgressBar runtimePodName="runtime-test" />);

      await vi.runAllTimersAsync();

      await waitFor(
        () => {
          expect(mockGetRuntime).toHaveBeenCalledWith('runtime-test');
          expect(mockGetRuntime).toHaveBeenCalledTimes(1);
        },
        { timeout: 100 }
      );
    });

    it('should handle API errors gracefully', async () => {
      const consoleError = vi
        .spyOn(console, 'error')
        .mockImplementation(() => {});
      mockGetRuntime.mockRejectedValue(new Error('API Error'));

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-error" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      // Should still render but with no percentage
      expect(container.firstChild).toBeInTheDocument();
      expect(consoleError).toHaveBeenCalled();

      consoleError.mockRestore();
    });

    it('should refetch when runtimePodName changes', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 1000).toISOString(),
        expiredAt: new Date(now + 59000).toISOString(),
      });

      const { rerender } = render(
        <RuntimeProgressBar runtimePodName="runtime-1" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalledWith('runtime-1');
      });

      rerender(<RuntimeProgressBar runtimePodName="runtime-2" />);

      await vi.runAllTimersAsync();

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalledWith('runtime-2');
        expect(mockGetRuntime).toHaveBeenCalledTimes(2);
      });
    });

    it('should clear runtime details when runtimePodName becomes undefined', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 1000).toISOString(),
        expiredAt: new Date(now + 59000).toISOString(),
      });

      const { rerender, container } = render(
        <RuntimeProgressBar runtimePodName="runtime-1" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      rerender(<RuntimeProgressBar />);

      await vi.runAllTimersAsync();

      // Should render nothing
      expect(container.firstChild).toBeNull();
    });
  });

  describe('percentage calculation', () => {
    it('should calculate correct initial percentage at 50% elapsed', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 30 * 60 * 1000); // Started 30 mins ago
      const expiredAt = new Date(now + 30 * 60 * 1000); // Expires in 30 mins

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      // Should be roughly 50% (some variance due to timing)
      const progressBar = container.querySelector('[style*="width"]');
      expect(progressBar).toBeInTheDocument();
      const width = progressBar
        ?.getAttribute('style')
        ?.match(/width: (\d+(\.\d+)?)%/)?.[1];
      expect(parseFloat(width || '0')).toBeGreaterThan(45);
      expect(parseFloat(width || '0')).toBeLessThan(55);
    });

    it('should show 0% for future runtime', async () => {
      const now = Date.now();
      const startedAt = new Date(now); // Just started
      const expiredAt = new Date(now + 60 * 60 * 1000); // Expires in 1 hour

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector('[style*="width"]');
      const width = progressBar
        ?.getAttribute('style')
        ?.match(/width: (\d+(\.\d+)?)%/)?.[1];
      expect(parseFloat(width || '0')).toBeLessThan(5);
    });

    it('should progress over time', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 10000); // Started 10 seconds ago
      const expiredAt = new Date(now + 50000); // Expires in 50 seconds (total 60s)

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const getWidth = () => {
        const progressBar = container.querySelector('[style*="width"]');
        const width = progressBar
          ?.getAttribute('style')
          ?.match(/width: (\d+(\.\d+)?)%/)?.[1];
        return parseFloat(width || '0');
      };

      const initialWidth = getWidth();

      // Advance time by 5 seconds
      vi.advanceTimersByTime(5000);

      await waitFor(() => {
        const newWidth = getWidth();
        expect(newWidth).toBeGreaterThan(initialWidth);
      });
    });
  });

  describe('color transitions', () => {
    it('should show green color for normal progress (<70%)', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 10000); // 10s elapsed
      const expiredAt = new Date(now + 90000); // 90s remaining (10% elapsed)

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector(
        '[style*="background-color"]'
      );
      expect(progressBar?.getAttribute('style')).toContain('16A085'); // Green
    });

    it('should show orange color for warning progress (>70%, <90%)', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 80000); // 80s elapsed
      const expiredAt = new Date(now + 20000); // 20s remaining (80% elapsed)

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector(
        '[style*="background-color"]'
      );
      expect(progressBar?.getAttribute('style')).toContain('FFA500'); // Orange
    });

    it('should show red color for critical progress (>90%)', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 95000); // 95s elapsed
      const expiredAt = new Date(now + 5000); // 5s remaining (95% elapsed)

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector(
        '[style*="background-color"]'
      );
      expect(progressBar?.getAttribute('style')).toContain('DC3545'); // Red
    });

    it('should show red color when expired (100%)', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 60000); // Started 60s ago
      const expiredAt = new Date(now - 1000); // Expired 1s ago

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector(
        '[style*="background-color"]'
      );
      expect(progressBar?.getAttribute('style')).toContain('DC3545'); // Red
    });
  });

  describe('countdown timer', () => {
    it('should set up interval to update percentage', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 10000);
      const expiredAt = new Date(now + 50000);

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      render(<RuntimeProgressBar runtimePodName="runtime-123" />);

      await vi.runAllTimersAsync();

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      // Verify timer is running
      const timerCount = vi.getTimerCount();
      expect(timerCount).toBeGreaterThan(0);
    });

    it('should clear interval on unmount', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 10000).toISOString(),
        expiredAt: new Date(now + 50000).toISOString(),
      });

      const { unmount } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const timersBefore = vi.getTimerCount();
      expect(timersBefore).toBeGreaterThan(0);

      unmount();

      // Timers should be cleared
      vi.runOnlyPendingTimers();
    });

    it('should mark as expired when countdown reaches zero', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 58000);
      const expiredAt = new Date(now + 2000); // 2 seconds remaining

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      // Advance time past expiration
      vi.advanceTimersByTime(3000);

      await waitFor(() => {
        const progressBar = container.querySelector('[style*="width: 100%"]');
        expect(progressBar).toBeInTheDocument();
      });
    });
  });

  describe('accessibility', () => {
    it('should be visually perceivable with appropriate height', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 1000).toISOString(),
        expiredAt: new Date(now + 59000).toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressContainer = container.querySelector(
        '[style*="height: 3px"]'
      );
      expect(progressContainer).toBeInTheDocument();
    });

    it('should have smooth transitions', async () => {
      const now = Date.now();
      mockGetRuntime.mockResolvedValue({
        startedAt: new Date(now - 1000).toISOString(),
        expiredAt: new Date(now + 59000).toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const progressBar = container.querySelector('[style*="transition"]');
      expect(progressBar?.getAttribute('style')).toContain('transition');
    });
  });

  describe('pulse animation', () => {
    it('should show pulse animation when in critical range (>90%, <100%)', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 92000);
      const expiredAt = new Date(now + 8000); // 92% elapsed

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      // Should have pulse animation element
      const pulseElement = container.querySelector('[style*="animation"]');
      expect(pulseElement).toBeInTheDocument();
    });

    it('should not show pulse animation for normal progress', async () => {
      const now = Date.now();
      const startedAt = new Date(now - 10000);
      const expiredAt = new Date(now + 90000); // 10% elapsed

      mockGetRuntime.mockResolvedValue({
        startedAt: startedAt.toISOString(),
        expiredAt: expiredAt.toISOString(),
      });

      const { container } = render(
        <RuntimeProgressBar runtimePodName="runtime-123" />
      );

      await waitFor(() => {
        expect(mockGetRuntime).toHaveBeenCalled();
      });

      const pulseElement = container.querySelector('[style*="animation"]');
      expect(pulseElement).not.toBeInTheDocument();
    });
  });
});
